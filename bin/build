#!/usr/bin/env node

/*
 * Rolls packages and generates a single typescript declaration file
 */


/*
Produces production builds and stitches together d.ts files.
To specify the package to build, simply pass its name and the desired build
formats to output (defaults to `buildOptions.formats` specified in that package,
or "esm,cjs"):
```
# name supports fuzzy match. will build all packages with name containing "dom":
yarn build dom
# specify the format to output
yarn build core --formats cjs
*/
const path = require('path');
const zlib = require('zlib');
const { promisify } = require('util');
const { readFile, access, rmdir } = require('fs/promises');
const gzip = promisify(zlib.gzip);
const brotli = promisify(zlib.brotliCompress);
const { rollPackage } = require('./roll');
const { resolvePackages } = require('./shared');
const PACKAGES_ROOT = path.resolve(__dirname, '../packages');

// maybe not use all of these?
// 
const args = require('minimist')(process.argv.slice(2));
const targets = args._;
const formats = args.formats || args.f;
const devOnly = args.devOnly || args.d;
const prodOnly = !devOnly && (args.prodOnly || args.p);
const sourceMap = args.sourcemap || args.s;
const isRelease = args.release;
const buildTypes = args.t || args.types || isRelease;
const buildAllMatching = args.all || args.a;
const { generateDtsBundle } = require('dts-bundle-generator');

async function exists(path) {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

function rmrf(path) {
  return rmdir(path, { recursive: true });
}

async function checkSize(target) {
  const { dir } = target;
  const filePath = path.resolve(dir, `dist/${target}.global.prod.js`);

  if (await exists(filePath)) {
    const file = (await readFile(filePath)).length;
    const gzipped = (await gzip(file)).length;
    const brotlied = (await brotli(file)).length;
    console.log(size`${path.basename(filePath)} min:${file} / gzip:${gzipped} / brotli:${brotlied}`);
  }
}

// Interpolate numbers as kb of number
function size(strings, ...values) {
  return strings.reduce((acc, str, idx) => {
    const value = values[idx - 1];

    if (typeof value == 'number') {
      value = `${(value / 1024).toFixed(2)}kb`;
    }
    return `${acc}${value}${str}`;
  });
}

async function build(target) {
  const { dir, package } = target;

  // only build published packages for release
  if (isRelease && package.private) {
    return;
  }

  // if building a specific format, do not remove dist.
  if (!formats) {
    await rmrf(`${dir}/dist`);
  }

  console.log(`${'\n'.repeat(2)}${package.name}`);
  await rollPackage(target);

  /*const input = createInput(dir);
  const bundle = await rollup(input);
  const outputs = createOutputs(package);

  for (const output of outputs) {
    output.dir = path.resolve(dir, 'dist/');
    await bundle.write(output);
  }*/

  /*const env = (package.buildOptions && package.buildOptions.env) || (devOnly ? 'development' : 'production');
  await execa(
    'rollup',
    [
      '-c',
      '--environment',
      [
        `NODE_ENV:${env}`,
        `TARGET:${target}`,
        formats ? `FORMATS:${formats}` : ``,
        buildTypes ? `TYPES:true` : ``,
        prodOnly ? `PROD_ONLY:true` : ``,
        sourceMap ? `SOURCE_MAP:true` : ``
      ]
        .filter(Boolean)
        .join(',')
    ],
    { stdio: 'inherit' }
  );*/

  if (buildTypes && package.types) {
    console.log(`\nRolling up type definitions for ${target}...`);

    // list all .ts files
    generateDtsBundle([]);

    // build types
    const { Extractor, ExtractorConfig } = require('@microsoft/api-extractor');

    const extractorConfigPath = path.resolve(dir, `api-extractor.json`);
    const extractorConfig = ExtractorConfig.loadFileAndPrepare(extractorConfigPath);
    const extractorResult = Extractor.invoke(extractorConfig, {
      localBuild: true,
      showVerboseMessages: true
    });

    if (extractorResult.succeeded) {
      /* concat additional d.ts to rolled-up dts
      const typesDir = path.resolve(dir, 'types');

      if (await exists(typesDir)) {
        const dtsPath = path.resolve(dir, package.types);
        //const existing = await readFile(dtsPath, 'utf-8');
        const typeFiles = await readdir(typesDir);
        const promises = typeFiles.map(file => readFile(path.resolve(typesDir, file), 'utf-8'))
        const toAdd = await Promise.all(promises);

        await writeFile(dtsPath, '\n' + toAdd.join('\n'), { flag: 'a' })
        //await writeFile(dtsPath, existing + '\n' + toAdd.join('\n'));
      }*/

      console.log(`API Extractor completed successfully.`);
    } else {
      console.error(`API Extractor completed with ${extractorResult.errorCount} errors and ${extractorResult.warningCount} warnings`);
      process.exitCode = 1;
    }

    await rmrf(`${dir}/dist/packages`);
  }
}

async function run() {
  if (isRelease) {
    // Remove build cache for release builds to avoid outdated enum values
    await rmrf(path.resolve(__dirname, '../node_modules/.rts2_cache'));
  }

  const packages = resolvePackages(PACKAGES_ROOT);


  // build types into ./lib folder
  // then roll all types with api-extractor in each build
  // after remove lib dir

  //let names = targets.length ? fuzzyMatchTarget(targets, buildAllMatching) : packages;
  let names = packages;
  for (const target of names.values()) {
    try {
      await build(target);
    } catch (ex) {
      console.error(ex);
    }
  }

  if (!devOnly) {
    console.log('');
    for (const target of names.values()) {
      await checkSize(target);
    }

    console.log('');
  }
}

run().catch(err => console.error(err));
