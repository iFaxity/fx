#!/usr/bin/env node

/*
 * Rolls packages and generates a single typescript declaration file
 */


/*
Produces production builds and stitches together d.ts files.
To specify the package to build, simply pass its name and the desired build
formats to output (defaults to `buildOptions.formats` specified in that package,
or "esm,cjs"):
```
# name supports fuzzy match. will build all packages with name containing "dom":
yarn build dom
# specify the format to output
yarn build core --formats cjs
*/
const path = require('path');
const zlib = require('zlib');
const { promisify } = require('util');
const { readFile, writeFile, access, rmdir } = require('fs/promises');
const gzip = promisify(zlib.gzip);
const brotli = promisify(zlib.brotliCompress);
const { rollPackage } = require('./roll');
const { resolvePackages } = require('./shared');
const PACKAGES_ROOT = path.resolve(__dirname, '../packages');

const args = require('yargs')
  .option('devOnly', {
    type: 'boolean',
    alias: 'd',
    default: false,
    description: 'Only builds for development',
  })
  .option('prodOnly', {
    type: 'boolean',
    alias: 'p',
    default: false,
    description: 'Only builds for production, ignored if devOnly is set',
  })
  .option('sourceMap', {
    type: 'boolean',
    alias: 's',
    default: true,
    description: 'Include sourcemaps in the build',
  })
  .option('types', {
    type: 'boolean',
    alias: 't',
    default: true,
    description: '',
  })
  .option('release', {
    type: 'boolean',
    default: false,
    description: 'Builds for release, ignores any private packages',
  })
  .option('formats', {
    type: 'array',
    alias: 'f',
    choices: [ 'cjs', 'esm', 'global', 'module' ],
    default: [],
    description: 'Formats to solely build targeted types',
  })
  // Special config
  .help('help').alias('h', 'help').argv;

/*
const prodOnly = !args.devOnly && args.prodOnly;
const buildTypes = args.types || args.release;*/
const { devOnly, sourceMap, release: isRelease, types: buildTypes } = args;
const formats = args.formats.length ? args.formats : null;
const targets = args._.length ? args._ : null;
const prodOnly = !devOnly && args.devOnly;

// Manually for now.
const PACKAGE_ORDER = [
  '@kirei/shared',
  '@kirei/html',
  '@kirei/element',
  '@kirei/hmr-api',
  '@kirei/router',
  '@kirei/store',
  '@kirei/ssr',
  'babel-plugin-kirei',
  '@kirei/vite-plugin',
];

async function exists(path) {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

function rmrf(path) {
  return rmdir(path, { recursive: true });
}

async function checkSize(dir, name) {
  const filename = name.includes('/') ? name.split('/', 2)[1] : name;
  const filePath = path.resolve(dir, `dist/${filename}.global.prod.js`);

  if (await exists(filePath)) {
    const file = await readFile(filePath);
    const gzipped = await gzip(file);
    const brotlied = await brotli(file);

    return [ file.length, gzipped.length, brotlied.length ];
  }
}

async function build(target, opts) {
  const { dir, package } = target;

  // only build published packages for release
  if (isRelease && package.private) {
    return;
  }

  // if building a specific format, do not remove dist.
  if (!formats) {
    await rmrf(`${dir}/dist`);
  }

  // Build package, with package execution time
  const start = Date.now();
  let completed = false;
  try {
    console.log(`\u001B[36;1mBuilding: ${package.name}\u001B[0m`);
    await rollPackage(target, opts);

    completed = true;
  } finally {
    const diff = (Date.now() - start) / 1000;
    const status = completed ? 'completed' : 'errored';
    const color = completed ? '\u001B[32;1m' : '\u001B[31;1m';
    console.log(`${color}Build ${status} after ${diff.toFixed(2)}s\u001B[0m\n`);
  }

  /* Not currently working with import/export type
  if (buildTypes && package.types) {
    const { generateDtsBundle } = require('dts-bundle-generator');
    console.log(`\nRolling up type definitions for ${package.name}...`);

    // list all .ts files
    const [ typings ] = generateDtsBundle([
      { filePath: path.resolve(dir, 'src/index.ts'), },
    ]);

    await writeFile(path.resolve(dir, package.types), typings, 'utf8');
  }*/
}

async function run() {
  const opts = { formats, devOnly, prodOnly, sourceMap };
  const matched = resolvePackages(PACKAGES_ROOT, false); // true when prod
  const pkgs = PACKAGE_ORDER.reduce((acc, key) => {
    const item = matched.get(key);

    if (item) {
      const dirname = path.basename(item.dir);
      if (!targets || targets.includes(key) || targets.includes(dirname)) {
        // if targets is defined, check if includes dir or package name
        acc.push([ key, item ]);
      }
    }

    return acc;
  }, []);

  for (const [ _, target ] of pkgs) {
    try {
      await build(target, opts);
    } catch (ex) {
      console.error(ex);
    }
  }

  if (!devOnly) {
    // Interpolate numbers as kb of number
    const results = [];
    const size = (value) => `${(value / 1024).toFixed(1)}kb`;

    for (const [ _, target ] of pkgs) {
      const pkgName = target.package.name;
      const res = await checkSize(target.dir, pkgName);

      if (res) {
        results.push(`${pkgName} production build: min: ${size(res[0])} / gzip: ${size(res[1])} / brotli: ${size(res[2])}`);
      }
    }

    if (results.length) {
      console.log(results.join('\n'));
    }
  }
}

run().catch(err => console.error(err));
