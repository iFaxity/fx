#!/usr/bin/env node

/*
 * Rolls packages and generates a single typescript declaration file
 */


/*
Produces production builds and stitches together d.ts files.
To specify the package to build, simply pass its name and the desired build
formats to output (defaults to `buildOptions.formats` specified in that package,
or "esm,cjs"):
```
# name supports fuzzy match. will build all packages with name containing "dom":
yarn build dom
# specify the format to output
yarn build core --formats cjs
*/
const path = require('path');
const zlib = require('zlib');
const { promisify } = require('util');
const { readFile, writeFile, access, rmdir, readdir } = require('fs/promises');
const gzip = promisify(zlib.gzip);
const brotli = promisify(zlib.brotliCompress);
const { rollup } = require('rollup');

const args = require('minimist')(process.argv.slice(2));
const targets = args._;
const formats = args.formats || args.f;
const devOnly = args.devOnly || args.d;
const prodOnly = !devOnly && (args.prodOnly || args.p);
const sourceMap = args.sourcemap || args.s;
const isRelease = args.release;
const buildTypes = args.t || args.types || isRelease;
const buildAllMatching = args.all || args.a;

async function exists(path) {
  try {
    await access(path);
    return true;
  } catch {
    return false;
  }
}

run();

async function run() {
  if (isRelease) {
    // Remove build cache for release builds to avoid outdated enum values
    await rmdir(path.resolve(__dirname, '../node_modules/.rts2_cache'), { recursive: true });
  }

  if (!targets.length) {
    await buildAll(allTargets);
    checkAllSizes(allTargets);
  } else {
    await buildAll(fuzzyMatchTarget(targets, buildAllMatching));
    checkAllSizes(fuzzyMatchTarget(targets, buildAllMatching));
  }
}

async function buildAll(targets) {
  for (const target of targets) {
    await build(target);
  }
}

async function build(target) {
  const pkgDir = path.resolve(__dirname, `../packages/${target}`);
  const pkg = require(`${pkgDir}/package.json`);

  // only build published packages for release
  if (isRelease && pkg.private) {
    return;
  }

  // if building a specific format, do not remove dist.
  if (!formats) {
    await rmdir(`${pkgDir}/dist`, { recursive: true });
  }

  

  /*const env = (pkg.buildOptions && pkg.buildOptions.env) || (devOnly ? 'development' : 'production');
  await execa(
    'rollup',
    [
      '-c',
      '--environment',
      [
        `NODE_ENV:${env}`,
        `TARGET:${target}`,
        formats ? `FORMATS:${formats}` : ``,
        buildTypes ? `TYPES:true` : ``,
        prodOnly ? `PROD_ONLY:true` : ``,
        sourceMap ? `SOURCE_MAP:true` : ``
      ]
        .filter(Boolean)
        .join(',')
    ],
    { stdio: 'inherit' }
  );*/

  if (buildTypes && pkg.types) {
    console.log(`\nRolling up type definitions for ${target}...`);

    // build types
    const { Extractor, ExtractorConfig } = require('@microsoft/api-extractor');

    const extractorConfigPath = path.resolve(pkgDir, `api-extractor.json`);
    const extractorConfig = ExtractorConfig.loadFileAndPrepare(extractorConfigPath);
    const extractorResult = Extractor.invoke(extractorConfig, {
      localBuild: true,
      showVerboseMessages: true
    });

    if (extractorResult.succeeded) {
      /* concat additional d.ts to rolled-up dts
      const typesDir = path.resolve(pkgDir, 'types');

      if (await exists(typesDir)) {
        const dtsPath = path.resolve(pkgDir, pkg.types);
        //const existing = await readFile(dtsPath, 'utf-8');
        const typeFiles = await readdir(typesDir);
        const promises = typeFiles.map(file => readFile(path.resolve(typesDir, file), 'utf-8'))
        const toAdd = await Promise.all(promises);

        await writeFile(dtsPath, '\n' + toAdd.join('\n'), { flag: 'a' })
        //await writeFile(dtsPath, existing + '\n' + toAdd.join('\n'));
      }*/

      console.log(`API Extractor completed successfully.`);
    } else {
      console.error(`API Extractor completed with ${extractorResult.errorCount} errors and ${extractorResult.warningCount} warnings`);
      process.exitCode = 1;
    }

    await rmdir(`${pkgDir}/dist/packages`, { recursive: true });
  }
}

function checkAllSizes(targets) {
  if (!devOnly) {
    console.log();
    for (const target of targets) {
      checkSize(target);
    }
    console.log();
  }
}

async function checkSize(target) {
  const pkgDir = path.resolve(__dirname, `../packages/${target}`);
  const filePath = path.resolve(pkgDir, `dist/${target}.global.prod.js`);

  if (await exists(filePath)) {
    const file = (await readFile(filePath)).length;
    const gzipped = (await gzip(file)).length;
    const brotlied = (await brotli(file)).length;
    console.log(size`${path.basename(filePath)} min:${file} / gzip:${gzipped} / brotli:${brotlied}`);
  }
}

// Interpolate numbers as kb of number
function size(strings, ...values) {
  return strings.reduce((acc, str, idx) => {
    const value = values[idx - 1];

    if (typeof value == 'number') {
      value = `${(value / 1024).toFixed(2)}kb`;
    }
    return `${acc}${value}${str}`;
  });
}
