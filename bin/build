#!/usr/bin/env node

/*
 * Rolls packages and generates a single typescript declaration file
 */


/*
Produces production builds and stitches together d.ts files.
To specify the package to build, simply pass its name and the desired build
formats to output (defaults to `buildOptions.formats` specified in that package,
or "esm,cjs"):
```
# name supports fuzzy match. will build all packages with name containing "dom":
yarn build dom
# specify the format to output
yarn build core --formats cjs
*/
const path = require('path');
const zlib = require('zlib');
const { promisify } = require('util');
const { readFile, writeFile, access, unlink, readdir } = require('fs/promises');
const gzip = promisify(zlib.gzip);
const brotli = promisify(zlib.brotliCompress);

const args = require('minimist')(process.argv.slice(2));
const targets = args._;
const formats = args.formats || args.f;
const devOnly = args.devOnly || args.d;
const prodOnly = !devOnly && (args.prodOnly || args.p);
const sourceMap = args.sourcemap || args.s;
const isRelease = args.release;
const buildTypes = args.t || args.types || isRelease;
const buildAllMatching = args.all || args.a;

run();

async function run() {
  if (isRelease) {
    // remove build cache for release builds to avoid outdated enum values
    await remove(path.resolve(__dirname, '../node_modules/.rts2_cache'));
  }
  if (!targets.length) {
    await buildAll(allTargets);
    checkAllSizes(allTargets);
  } else {
    await buildAll(fuzzyMatchTarget(targets, buildAllMatching));
    checkAllSizes(fuzzyMatchTarget(targets, buildAllMatching));
  }
}

async function buildAll(targets) {
  for (const target of targets) {
    await build(target);
  }
}

async function build(target) {
  const pkgDir = path.resolve(`packages/${target}`);
  const pkg = require(`${pkgDir}/package.json`);

  // only build published packages for release
  if (isRelease && pkg.private) {
    return;
  }

  // if building a specific format, do not remove dist.
  if (!formats) {
    await remove(`${pkgDir}/dist`);
  }

  const env = (pkg.buildOptions && pkg.buildOptions.env) || (devOnly ? 'development' : 'production');
  await execa(
    'rollup',
    [
      '-c',
      '--environment',
      [
        `NODE_ENV:${env}`,
        `TARGET:${target}`,
        formats ? `FORMATS:${formats}` : ``,
        buildTypes ? `TYPES:true` : ``,
        prodOnly ? `PROD_ONLY:true` : ``,
        sourceMap ? `SOURCE_MAP:true` : ``
      ]
        .filter(Boolean)
        .join(',')
    ],
    { stdio: 'inherit' }
  );

  if (buildTypes && pkg.types) {
    console.log();
    console.log(
      chalk.bold(chalk.yellow(`Rolling up type definitions for ${target}...`))
    );

    // build types
    const { Extractor, ExtractorConfig } = require('@microsoft/api-extractor');

    const extractorConfigPath = path.resolve(pkgDir, `api-extractor.json`);
    const extractorConfig = ExtractorConfig.loadFileAndPrepare(
      extractorConfigPath
    );
    const extractorResult = Extractor.invoke(extractorConfig, {
      localBuild: true,
      showVerboseMessages: true
    });

    function exists() {
      return exists
    }

    function exists(path) {
      try {
        accessSync(path, constants.W_OK);
        return true;
      } catch {
        return false;
      }
    }

    if (extractorResult.succeeded) {
      // concat additional d.ts to rolled-up dts
      const typesDir = path.resolve(pkgDir, 'types');
      accessSync(typesDir);
      if (await exists(typesDir)) {
        const dtsPath = path.resolve(pkgDir, pkg.types);
        const existing = await readFile(dtsPath, 'utf-8');
        const typeFiles = await readdir(typesDir);
        const promises = typeFiles.map(file => readFile(path.resolve(typesDir, file), 'utf-8'))
        const toAdd = await Promise.all(promises);
        await writeFile(dtsPath, existing + '\n' + toAdd.join('\n'));
      }
      console.log(`API Extractor completed successfully.`);
    } else {
      console.error(`API Extractor completed with ${extractorResult.errorCount} errors and ${extractorResult.warningCount} warnings`);
      process.exitCode = 1;
    }

    await remove(`${pkgDir}/dist/packages`);
  }
}

function checkAllSizes(targets) {
  if (!devOnly) {
    console.log();
    for (const target of targets) {
      checkSize(target);
    }
    console.log();
  }
}

async function checkSize(target) {
  const pkgDir = path.resolve(`packages/${target}`);
  const filePath = path.join(pkgDir, `dist/${target}.global.prod.js`);

  const lel = await access(filePath);

  if () {
    return;
  }

  const file = await readFile(filePath);
  const gzipped = gzip(file);
  const brotlied = brotli(file);
  console.log(size`${path.basename(filePath)} min:${file.length} / gzip:${gzipped.length} / brotli:${brotlied.length}`);
}

// Interpolate numbers as kb of number
function size(strings, ...values) {
  return strings.reduce((acc, str, idx) => {
    const value = values[idx - 1];

    if (typeof value == 'number') {
      value = `${(value / 1024).toFixed(2)}kb`;
    }
    return `${acc}${value}${str}`;
  });
}
