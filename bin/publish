#!/usr/bin/env node
//
// Script to synchronize publishing for all packages
//

const { readdirSync, readFileSync, writeFileSync, statSync } = require('fs');
const { execSync } = require('child_process');
const path = require('path');

const ROOT_DIR = path.join(__dirname, '../');
const PACKAGES_DIR = path.join(ROOT_DIR, 'packages');
const rootPkg = require('../package.json');
const semver = [ 'major', 'minor', 'patch' ];

// json file operations
function readJSON(filepath) {
  const data = readFileSync(filepath, 'utf8');
  return JSON.parse(data);
}

function writeJSON(filepath, data) {
  const json = JSON.stringify(data, null, 2);
  writeFileSync(filepath, json, 'utf8');
}

// Executes a shell command
function shell(cmd, package) {
  const cwd = package ? path.join(PACKAGES_DIR, package) : ROOT_DIR;
  execSync(cmd, { cwd, encoding: 'utf8' });
}

// Bumps the version from the root package
function bumpVersion(tag) {
  // ${{ github.ref }} format
  if (tag.startsWith('refs/tags/v')) {
    return tag.substring(11);
  } else if (tag[0] == 'v') {
    return tag.substring(1);
  }

  const idx = semver.indexOf(tag);
  const version = rootPkg.version.split('.').map(Number);

  // Fallthrough for version
  switch(idx) {
    case 0:
      version[0] += 1;
    case 1:
      version[1] = idx == 1 ? version[1] + 1 : 0;
    case 2:
      version[2] = idx == 2 ? version[2] + 1 : 0;
      break;
    default:
      throw new Error(`Version '${tag}' tag not recognised`);
  }
  return version.join('.');
}

// Assures that all linked dependencies gets bumped too
function bumpDependencies(dir, pkg, version) {
  const keys = [ 'dependencies', 'peerDependencies', 'devDependencies'];

  for (const key of keys) {
    const deps = pkg[key];
    if (!deps) continue;

    for (const dep of Object.keys(deps)) {
      if (dep in packages) {
        deps[dep] = `^${version}`;
      }
    }
  }

  writeJSON(path.join(dir, 'package.json'), pkg);
}

function resolvePackages(rootDir) {
  const packages = readdirSync(rootDir);

  return packages.reduce((acc, name) => {
    const dir = path.join(PACKAGES_DIR, name);
    const stats = statSync(rootDir);

    // Only publish directories with package.json set to public
    if (stats.isDirectory()) {
      const package = readJSON(path.join(dir, 'package.json'));

      if (package.private !== true) {
        acc.set(package.name, { package, path: dir });
      }
    }

    return acc;
  }, new Map());
}

// Program entrypoint
const tag = process.argv[2] || 'patch';
const version = bumpVersion(tag);
const packages = resolvePackages(PACKAGES_DIR);

console.log(`v${rootPkg.version} --> v${version}`);

// Update version in root package
rootPkg.version = version;
writeJSON(path.join(ROOT_DIR, 'package.json'), rootPkg);

// Upgrade peer packages
for (const { package, path } of packages.values()) {
  bumpDependencies(path, package, version);
}

// Create a commit with a release tag
shell(`git commit -am 'Release v${version}'`);
shell('git push');

// Finally publish to NPM
for (const [ name, package ] of packages) {
  console.log(`Publishing package ${name} (v${version})`);
  shell(`yarn publish --new-version ${version} --no-git-tag-version --access public`, package.path);
}

console.log('Done');
